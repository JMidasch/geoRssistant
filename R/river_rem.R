#' Compute REM (Relative Elevation Model) from DEM and River Centerlines
#'
#' This function processes a high-resolution Digital Elevation Model (DEM) and existing river centerlines
#' to compute a Relative Elevation Model (REM). The REM highlights areas of elevation difference like paleochannels
#' by interpolating along the river centerlines and comparing the interpolated surface to the DEM.
#'
#' @details
#' The function performs the following steps:
#' 1. Reads the input DEM and river centerlines.
#' 2. Samples points along the river centerlines at regular intervals based on the specified river width.
#' 3. Interpolates an elevation surface from the sampled points using Inverse Distance Weighting (IDW).
#' 4. Resamples the interpolated surface to match the DEM resolution.
#' 5. Computes the REM by subtracting the interpolated surface from the DEM.
#' 6. Save the REM at the specified location
#'
#' The function expects the river centerlines to be provided as an `sf` object or a shapefile with `LINESTRING` geometries.
#' If the geometries are `MULTILINESTRING`, they are automatically cast to `LINESTRING`.
#'
#' @param input_raster Path to the input DEM file in GeoTIFF format (`.tif`).
#' @param centerlines Either a `sf` object or a path to a shapefile containing river centerlines.
#' @param river_width Numeric. The width of the river network (in units of the DEM's projection), used for creating regular points along the river centerline.
#' @param output_raster Location the REM should be saved to. Defaults to the input_raster with a '_rem.tif' suffix.
#'
#' @return A `SpatRaster` object representing the Raster Elevation Model (REM) generated by subtracting the IDW interpolated raster from the original DEM.
#' The REM raster highlights areas of difference between the DEM and the interpolated values.
#'
#' @examples
#' \dontrun{
#' # Compute REM from an input DEM and river centerlines
#' rem_raster <- river.rem(
#'   input_raster = "path_to_dem.tif",
#'   centerlines = "path_to_centerlines.shp",
#'   river_width = 50
#'   output_raster = "path_to_output.tif"
#' )
#' }
#' @importFrom terra rast plot resample interpolate extract res crs ext vect
#' @importFrom gstat gstat
#' @importFrom tools file_path_sans_ext
#' @importFrom sf st_line_sample st_cast st_as_sf st_coordinates st_read st_geometry_type st_transform
#'
#' @export

river.rem <- function(input_raster, centerlines, river_width, output_raster = " ") {
  # Validate the input DEM
  if (!file.exists(input_raster) || !grepl("\\.tif$", input_raster)) {
    stop("Invalid input: The DEM file is either missing or not a .tif file.")
  }

  # Validate or read the centerlines
  if (inherits(centerlines, "sf")) {
    # If centerlines is already an sf object, ensure it's valid
  } else if (is.character(centerlines) && file.exists(centerlines) && grepl("\\.shp$", centerlines)) {
    # If centerlines is a file path, read it as an sf object
    centerlines <- st_read(centerlines)
  } else {
    stop("Invalid input: 'centerlines' should be an sf object or a valid shapefile path.")
  }

  # Ensure centerlines are LINESTRING geometries
  if (!all(st_geometry_type(centerlines) == "LINESTRING")) {
    centerlines <- st_cast(centerlines, "LINESTRING", warn = FALSE)
    centerlines$id <- seq_len(nrow(centerlines))  # Add unique IDs to avoid attribute mismatches
    centerlines <- centerlines[, c("id", "geometry")]  # Keep only ID and geometry columns
  }

  # Open the DEM
  dem_raster <- rast(input_raster)

  # Ensure that the centerlines have the same CRS as the DEM
  centerlines <- st_transform(centerlines, crs(dem_raster))  # Transform to the same CRS as the DEM

  # Generate points along the centerlines
  centerpoints <- st_line_sample(centerlines, density = 1 / river_width, type = "regular")
  centerpoints <- st_cast(centerpoints, "POINT")

  # Convert sampled points to a SpatVector
  centerpoints_coords <- sf::st_coordinates(centerpoints)  # Extract coordinates from points
  centerpoints_vect <- terra::vect(centerpoints_coords, crs = crs(dem_raster))  # Create SpatVector

  # Extract raster values at point locations
  values <- terra::extract(dem_raster, centerpoints_vect)

  # Prepare data frame for IDW interpolation
  centerpoints_df <- data.frame(
    x = centerpoints_coords[, 1],
    y = centerpoints_coords[, 2],
    values = values[, 2]  # Column 2 contains raster values
  )

  # Calculate new resolution (10x larger cell size)
  new_res <- terra::res(dem_raster) * 10

  # Create a new raster with coarser resolution
  coarse_raster <- rast(ext(dem_raster), res = new_res, crs = crs(dem_raster))

  # Create a gstat object for IDW
  idw_model <- gstat::gstat(
    formula = values ~ 1,
    locations = ~ x + y,
    data = centerpoints_df,
    set = list(idp = 2)
  )

  # Perform interpolation on the coarse raster grid
  idw_raster <- interpolate(coarse_raster, idw_model)

  # Extract only the `var1.pred` band
  idw_raster <- idw_raster[["var1.pred"]]

  # Resample IDW raster to match the DEM resolution
  upsampled_idw <- resample(idw_raster, dem_raster, method = "bilinear", verbose = FALSE)

  # Calculate REM by subtracting upsampled_idw from dem_raster
  rem <- dem_raster - upsampled_idw

  # Save the REM raster to disk
  if (output_raster == " "){
    output_raster <- paste0(tools::file_path_sans_ext(input_raster), "_rem.tif")
  }
  writeRaster(rem, output_raster, overwrite = TRUE, verbose = FALSE)

  return(rem)
}
